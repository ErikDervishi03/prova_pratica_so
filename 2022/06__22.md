> link alla prova : http://www.cs.unibo.it/~renzo/so/pratiche/2022.06.22.pdf


# Esercizio 1

## rx
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

void handler(int signo, siginfo_t *info, void *extra) {
    if (signo == SIGUSR1) {
        printf("Received SIGUSR1\n");
        printf("Signal sent by process: %d\n", info->si_pid);
        
        char str[9];
        memset(str, 0, 9);
        memcpy(str, &info->si_value.sival_ptr, sizeof(info->si_value.sival_ptr));
        
        printf("stringa ricevuta: %s\n", str);
    }
}

int main() {

    printf("pid : %d\n", getpid());

    struct sigaction act;

    memset(&act, 0, sizeof(act));
    act.sa_sigaction = handler;
    act.sa_flags = SA_SIGINFO;

    if (sigaction(SIGUSR1, &act, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    // Wait for a signal to arrive
    while (1) {
        pause();
    }

    return 0;
}

```

## tx

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <PID> <string>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    pid_t pid = atoi(argv[1]);
    char *data = argv[2];
    if (strlen(data) > 8) {
        fprintf(stderr, "Error: St 4ring length should not exceed 8 characters.\n");
        exit(EXIT_FAILURE);
    }

    union sigval value;

    value.sival_ptr = 0;
    memcpy(&value.sival_ptr, data, strlen(data));

    if (sigqueue(pid, SIGUSR1, value) == -1) {
        perror("sigqueue");
        exit(EXIT_FAILURE);
    }

    return 0;
}

```

# Esercizio 2

## rx
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#define MAX_CHUNKS 1024
#define CHUNK_SIZE 8

char buffer[MAX_CHUNKS * CHUNK_SIZE];
int current_chunk = 0;

void handler(int signo, siginfo_t *info, void *extra) {
    if (signo == SIGUSR1) {
        memcpy(&buffer[current_chunk * CHUNK_SIZE], &info->si_value.sival_ptr, CHUNK_SIZE);
        current_chunk++;
    } else if (signo == SIGUSR2) {
        buffer[current_chunk * CHUNK_SIZE] = '\0'; // Null-terminate the string
        printf("Received complete string: %s\n", buffer);
        current_chunk = 0; // Reset for the next string
    }
}

int main() {

     printf("pid : %d\n", getpid());

    struct sigaction act;

    memset(&act, 0, sizeof(act));
    act.sa_sigaction = handler;
    act.sa_flags = SA_SIGINFO;

    if (sigaction(SIGUSR1, &act, NULL) == -1 || sigaction(SIGUSR2, &act, NULL) == -1) {
        perror("sigaction");
        exit(EXIT_FAILURE);
    }

    // Wait for a signal to arrive
    while (1) {
        pause();
    }

    return 0;
}

```

## tx
```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#define CHUNK_SIZE 8

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <PID> <string>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    pid_t pid = atoi(argv[1]);
    char *data = argv[2];
    size_t length = strlen(data);
    union sigval value;

    for (size_t i = 0; i < length; i += CHUNK_SIZE) {
        char chunk[CHUNK_SIZE] = {0};
        strncpy(chunk, data + i, CHUNK_SIZE);
        value.sival_ptr = 0;
        memcpy(&value.sival_ptr, chunk, CHUNK_SIZE);

        if (sigqueue(pid, SIGUSR1, value) == -1) {
            perror("sigqueue");
            exit(EXIT_FAILURE);
        }
        usleep(10000); // Add a small delay to ensure proper signal handling
    }

    // Send SIGUSR2 to indicate the end of the string transfer
    if (sigqueue(pid, SIGUSR2, value) == -1) {
        perror("sigqueue");
        exit(EXIT_FAILURE);
    }

    return 0;
}

```


# Esercizio3

```python
import os
import sys
import subprocess

def categorize_files(directory):
    categories = {}

    for root, dirs, files in os.walk(directory):
        for name in dirs + files:
            path = os.path.join(root, name)
            if os.path.isdir(path):
                file_type = 'directory'
            else:
                file_type = subprocess.getoutput(f'file -b "{path}"')
            if file_type not in categories:
                categories[file_type] = []
            categories[file_type].append(name)

    return categories

def print_catalog(categories):
    for category, items in categories.items():
        print(f"{category}:")
        for item in items:
            print(f"  {item}")
        print()

if __name__ == "__main__":
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        directory = os.getcwd()

    categories = categorize_files(directory)
    print_catalog(categories)

```
