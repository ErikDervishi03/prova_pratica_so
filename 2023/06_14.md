> link alla prova : http://www.cs.unibo.it/~renzo/so/pratiche/2023.06.14.pdf

# Esercizio 1
> questo era tostissimo. mi sono aiutato con chatgpt
```c
#include <err.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/timerfd.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#include <string.h>


/*
  gli passi 4,1.1,ciao come stringa 
  e ti ritorna la lista degli elementi [4,1.1,ciao]
*/
char **parse_argv(char *s) {
    char **result = NULL;
    int size = 0;
    int index = 0;
    char *t = s;
    char *start = s;

    // Alloca memoria per l'array di puntatori
    while (*t != '\0') {
        if (*t == ',') {
            size++;
        }
        t++;
    }
    size++; // For the last element

    result = (char **)malloc(size * sizeof(char *));
    if (!result) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    t = s;
    while (*t != '\0') {
        if (*t == ',') {
            *t = '\0';  // Imposta il terminatore di stringa
            result[index++] = start;  // Aggiungi il puntatore alla sottostringa
            start = t + 1;  // Passa al prossimo carattere dopo la virgola
        }
        t++;
    }
    result[index] = start;  // Aggiungi l'ultimo puntatore

    return result;
}

/*

  funzione che ho copiato dal manuale : https://www.man7.org/linux/man-pages/man2/timerfd_create.2.html

*/
static void print_elapsed_time(void) {
    int secs, nsecs;
    static int first_call = 1;
    struct timespec curr;
    static struct timespec start;

    if (first_call) {
        first_call = 0;
        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)
            err(EXIT_FAILURE, "clock_gettime");
    }

    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)
        err(EXIT_FAILURE, "clock_gettime");

    secs = curr.tv_sec - start.tv_sec;
    nsecs = curr.tv_nsec - start.tv_nsec;
    if (nsecs < 0) {
        secs--;
        nsecs += 1000000000;
    }
    printf("%d.%03d: ", secs, (nsecs + 500000) / 1000000);
}


void double_to_timespec(double d, struct timespec *ts) {
    ts->tv_sec = (time_t)d; // integral part to seconds
    ts->tv_nsec = (long)((d - (time_t)d) * 1e9); // fractional part to nanoseconds
}

int start_timer(int cicli, double intervalli, const char *message) {
    int fd;
    ssize_t s;
    uint64_t exp, tot_exp;
    struct timespec now;
    struct itimerspec new_value;

    if (clock_gettime(CLOCK_REALTIME, &now) == -1)
        err(EXIT_FAILURE, "clock_gettime");

    double_to_timespec(intervalli, &new_value.it_value);
    new_value.it_value.tv_sec += now.tv_sec;
    new_value.it_value.tv_nsec += now.tv_nsec;
    if (new_value.it_value.tv_nsec >= 1e9) {
        new_value.it_value.tv_sec++;
        new_value.it_value.tv_nsec -= 1e9;
    }
    double_to_timespec(intervalli, &new_value.it_interval);

    fd = timerfd_create(CLOCK_REALTIME, 0);
    if (fd == -1)
        err(EXIT_FAILURE, "timerfd_create");

    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)
        err(EXIT_FAILURE, "timerfd_settime");

    print_elapsed_time();
    printf("timer started\n");

    for (int i = 0, tot_exp = 0; i < cicli; i++) {
        s = read(fd, &exp, sizeof(uint64_t));
        if (s != sizeof(uint64_t))
            err(EXIT_FAILURE, "read");

        tot_exp += exp;
        print_elapsed_time();
        printf("total=%" PRIu64 " %s\n", tot_exp, message);
    }

    close(fd);
    return 0;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <cicli,intervalli,message>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    char **result = parse_argv(argv[1]);

    int cicli = atoi(result[0]);
    double intervalli = atof(result[1]);
    const char *message = result[2];

    start_timer(cicli, intervalli, message);

    free(result);
    exit(EXIT_SUCCESS);
}
```

# Esercizio 2

```c
#include <err.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/timerfd.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
#include <string.h>
#include <pthread.h>

typedef struct {
    int cicli;
    float intervalli;
    char *message;
} TimerArgs;

/*
  gli passi 4,1.1,ciao come stringa 
  e ti ritorna la lista degli elementi [4,1.1,ciao]
*/
char **parse_argv(char *s) {
    char **result = NULL;
    int size = 0;
    int index = 0;
    char *t = s;
    char *start = s;

    // Alloca memoria per l'array di puntatori
    while (*t != '\0') {
        if (*t == ',') {
            size++;
        }
        t++;
    }
    size++; // For the last element

    result = (char **)malloc(size * sizeof(char *));
    if (!result) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    t = s;
    while (*t != '\0') {
        if (*t == ',') {
            *t = '\0';  // Imposta il terminatore di stringa
            result[index++] = start;  // Aggiungi il puntatore alla sottostringa
            start = t + 1;  // Passa al prossimo carattere dopo la virgola
        }
        t++;
    }
    result[index] = start;  // Aggiungi l'ultimo puntatore

    return result;
}

/*
  funzione che ho copiato dal manuale : https://www.man7.org/linux/man-pages/man2/timerfd_create.2.html
*/
static void print_elapsed_time(void) {
    int secs, nsecs;
    static int first_call = 1;
    struct timespec curr;
    static struct timespec start;

    if (first_call) {
        first_call = 0;
        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)
            err(EXIT_FAILURE, "clock_gettime");
    }

    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)
        err(EXIT_FAILURE, "clock_gettime");

    secs = curr.tv_sec - start.tv_sec;
    nsecs = curr.tv_nsec - start.tv_nsec;
    if (nsecs < 0) {
        secs--;
        nsecs += 1000000000;
    }
    printf("%d.%03d: ", secs, (nsecs + 500000) / 1000000);
}

void double_to_timespec(double d, struct timespec *ts) {
    ts->tv_sec = (time_t)d; // integral part to seconds
    ts->tv_nsec = (long)((d - (time_t)d) * 1e9); // fractional part to nanoseconds
}

void *start_timer(void *args) {
    int cicli = ((TimerArgs *)args)->cicli;
    float intervalli = ((TimerArgs *)args)->intervalli;
    char* message = ((TimerArgs *)args)->message;
    int fd;
    ssize_t s;
    uint64_t exp, tot_exp;
    struct timespec now;
    struct itimerspec new_value;

    if (clock_gettime(CLOCK_REALTIME, &now) == -1)
        err(EXIT_FAILURE, "clock_gettime");

    double_to_timespec(intervalli, &new_value.it_value);
    new_value.it_value.tv_sec += now.tv_sec;
    new_value.it_value.tv_nsec += now.tv_nsec;
    if (new_value.it_value.tv_nsec >= 1e9) {
        new_value.it_value.tv_sec++;
        new_value.it_value.tv_nsec -= 1e9;
    }
    double_to_timespec(intervalli, &new_value.it_interval);

    fd = timerfd_create(CLOCK_REALTIME, 0);
    if (fd == -1)
        err(EXIT_FAILURE, "timerfd_create");

    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)
        err(EXIT_FAILURE, "timerfd_settime");

    for (int i = 0, tot_exp = 0; i < cicli; i++) {
        s = read(fd, &exp, sizeof(uint64_t));
        if (s != sizeof(uint64_t))
            err(EXIT_FAILURE, "read");

        tot_exp += exp;
        print_elapsed_time();
        printf("total=%" PRIu64 " %s\n", tot_exp, message);
    }

    close(fd);

    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <cicli,intervalli,message> [...]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    pthread_t *alarms = (pthread_t *)malloc((argc - 1) * sizeof(pthread_t));
    if (!alarms) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        TimerArgs *args = malloc(sizeof(TimerArgs));
        if (!args) {
            perror("malloc");
            exit(EXIT_FAILURE);
        }

        char **result = parse_argv(argv[i]);
        args->cicli = atoi(result[0]);
        args->intervalli = atof(result[1]);
        args->message = result[2];

        int ret = pthread_create(&alarms[i - 1], NULL, start_timer, args);
        if (ret != 0) {
            perror("pthread_create");
            free(args);
            exit(EXIT_FAILURE);
        }

        free(result);  // Free the memory allocated for the result array
    }

    for (int i = 1; i < argc; ++i) {
        pthread_join(alarms[i - 1], NULL);
    }

    free(alarms);  // Free the memory allocated for threads

    return 0;
}

```

# Esercizio 3

```python
import os
import sys

def cancella_link_simbolici(directory):
    for root, dirs, files in os.walk(directory):
        for file in files:
            filepath = os.path.join(root, file)
            if os.path.islink(filepath):
                link_path = os.readlink(filepath)
                if not os.path.isabs(link_path):  # Verifica se è un link relativo
                    os.remove(filepath)
                    print(f"Link simbolico relativo cancellato: {filepath}")

if __name__ == "__main__":
    directory = sys.argv[1]
    if not os.path.isdir(directory):
        print("Il percorso specificato non è una directory valida.")
        sys.exit(1)

    cancella_link_simbolici(directory)

```
