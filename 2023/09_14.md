> link della prova : http://www.cs.unibo.it/~renzo/so/pratiche/2023.09.14.pdf

# Esercizio 1

## vreaddir.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>

char **vreaddir(const char *path) {
    int n = 0, i = 0;
    DIR *d;
    struct dirent *dir;
    d = opendir(path);

    if (d == NULL) {
        perror("opendir");
        return NULL;
    }

    while ((dir = readdir(d)) != NULL) {
        if (strcmp(dir->d_name, ".") != 0 && strcmp(dir->d_name, "..") != 0) {
            n++;
        }
    }
    rewinddir(d);

    char **filesList = (char **)malloc((n + 1) * sizeof(char *));

    while ((dir = readdir(d)) != NULL) {
        if (strcmp(dir->d_name, ".") != 0 && strcmp(dir->d_name, "..") != 0) {
            filesList[i] = (char *)malloc(strlen(dir->d_name) + 1);
            strcpy(filesList[i], dir->d_name);
            i++;
        }
    }

    filesList[n] = NULL;

    closedir(d);
    return filesList;
}
```

## test_vreaddir.c
> non mi vengono in mente altri modi per testarlo
```c
#include "es1.c"
#include <stdio.h>


int main(int argc, char *argv[])
{
  char ** list  = vreaddir(argv[1]);

  int i = 0;

  while(*list != 0)
  {
    printf("elemento numero %d : %s \n", i+1, *list);
    ++list;
    i++;
  }

return 0;
}
```

# Esercizio 2

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>

char **vreaddir(const char *path) {
    int n = 0, total_length = 0;
    DIR *d;
    struct dirent *dir;
    d = opendir(path);

    if (d == NULL) {
        perror("opendir");
        return NULL;
    }

    // Determinare il numero di file e la lunghezza totale delle stringhe
    while ((dir = readdir(d)) != NULL) {
        if (strcmp(dir->d_name, ".") != 0 && strcmp(dir->d_name, "..") != 0) {
            n++;
            total_length += strlen(dir->d_name) + 1; // +1 per il terminatore nullo
        }
    }
    rewinddir(d);

    // Allocazione memoria per l'array di puntatori e le stringhe
    char **filesList = (char **)malloc((n + 1) * sizeof(char *) + total_length * sizeof(char));
    if (filesList == NULL) {
        perror("malloc");
        closedir(d);
        return NULL;
    }

    // Puntatore alla posizione delle stringhe
    char *string_storage = (char *)(filesList + n + 1);
    int i = 0;

    // Inserire i nomi dei file nell'array
    while ((dir = readdir(d)) != NULL) {
        if (strcmp(dir->d_name, ".") != 0 && strcmp(dir->d_name, "..") != 0) {
            filesList[i] = string_storage;
            strcpy(filesList[i], dir->d_name);
            string_storage += strlen(dir->d_name) + 1; // +1 per il terminatore nullo
            i++;
        }
    }
    closedir(d);

    filesList[n] = NULL;

    return filesList;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <directory>\n", argv[0]);
        return EXIT_FAILURE;
    }

    char **list = vreaddir(argv[1]);

    for (int i = 0; list[i] != NULL; i++) {
        printf("%s\n", list[i]);
    }

    free(list); 

    return EXIT_SUCCESS;
}

```

# Esercizio 3

```python
from pathlib import Path
import sys
import os

if len(sys.argv) < 3:
    print("Usage: python script.py <directory> <target_path>")
    sys.exit(1)

directory = sys.argv[1]
target_path = Path(sys.argv[2]).resolve()

for subdir, dirs, files in os.walk(directory):
    for file in files:
        file_path = Path(subdir) / file
        if file_path.is_symlink():
            if file_path.resolve() == target_path:
                print(file_path)
```
