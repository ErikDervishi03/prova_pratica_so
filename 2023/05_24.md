> link alla prova : http://www.cs.unibo.it/~renzo/so/pratiche/2023.05.24.pdf

# Esercizio 1

```c
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <sys/types.h>
#include <unistd.h>

#define CMDLINE_PATH_SIZE 256
#define CMDLINE_BUFFER_SIZE 1024

/*
    legge il cotenuto del file cmdline (nel quale ci sono gli argomenti
    separati da carattere terminatore) e li restituisce separati da uno spazio

    es : "less\0/etc/hostname\0" ==> "less /etc/hostname\0"
*/
void read_cmdline(char *path, char *buffer, size_t size) {
    FILE *file = fopen(path, "r");
    if (file) {
        size_t read_size = fread(buffer, 1, size - 1, file);
        buffer[read_size] = '\0';
        fclose(file);

        // Replace null characters with spaces
        for (size_t i = 0; i < read_size; i++) {
            if (buffer[i] == '\0' && i + 1 != read_size) {
                buffer[i] = ' ';
            }
        }
    } else {
        buffer[0] = '\0';
    }
}

/*
    dato argc e argv ritorna gli argomenti di argv
    in una stringa con gli elementi separati da spazi

    es : construct_target_cmd(3, ["./pidcmd","less","/etc/hostname"]) ==> "less /etc/hostname"
*/
char* construct_target_cmd(int argc, char *argv[]) {
    size_t target_cmd_len = 0;
    for (int i = 1; i < argc; i++) {
        target_cmd_len += strlen(argv[i]) + 1;
    }

    char *target_cmd = malloc(target_cmd_len);
    if (!target_cmd) {
        perror("malloc");
        exit(1);
    }

    strcpy(target_cmd, argv[1]);
    for (int i = 2; i < argc; i++) {
        strcat(target_cmd, " ");
        strcat(target_cmd, argv[i]);
    }

    return target_cmd;
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <command> [args...]\n", argv[0]);
        return 1;
    }

    char *target_cmd = construct_target_cmd(argc, argv);

    DIR *proc_dir = opendir("/proc");
    if (!proc_dir) {
        perror("opendir");
        free(target_cmd);
        return 1;
    }

    struct dirent *entry;
    int count = 0;
    while ((entry = readdir(proc_dir)) != NULL) {
        if (entry->d_type == DT_DIR && isdigit(entry->d_name[0])) {
            char cmdline_path[CMDLINE_PATH_SIZE];
            snprintf(cmdline_path, CMDLINE_PATH_SIZE, "/proc/%s/cmdline", entry->d_name);
            
            char cmdline[CMDLINE_BUFFER_SIZE];
            read_cmdline(cmdline_path, cmdline, CMDLINE_BUFFER_SIZE);

            if (strcmp(cmdline, target_cmd) == 0) {
                count++;
                printf("processo numero [%d] ==> pid(%s)\n", count, entry->d_name);
            }
        }
    }

    printf("ci sono [%d] processi attivi che hanno lanciato [%s]\n", count, target_cmd);
    closedir(proc_dir);
    free(target_cmd);
    return 0;
}

```

# Esercizio 2

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#define PATH_SIZE 256
#define BUFFER_SIZE 10000

/*
    legge il cotenuto del file (nel quale ci sono gli argomenti
    separati da carattere terminatore) e li restituisce separati da uno spazio

    es : "less\0/etc/hostname\0" ==> "less /etc/hostname\0"
*/
void read_file(char *path, char *buffer, size_t size) {
    FILE *file = fopen(path, "r");
    if (file) {
        size_t read_size = fread(buffer, 1, size - 1, file);
        buffer[read_size] = '\0';
        fclose(file);

        // Replace null characters with spaces
        for (size_t i = 0; i < read_size; i++) {
            if (buffer[i] == '\0' && i + 1 != read_size) {
                buffer[i] = ' ';
            }
        }
    } else {
        buffer[0] = '\0';
    }
}

/*

    legge il contenuto di un buffer in cui gli
    elementi sono separati da uno spazio e mette gli 
    elementi in una lista del tipo {elemento1, elemento2, ..., NULL} ,la quale
    ci servira' dopo quando faremo execve

*/
void parse_buffer(char *buffer, char **list, size_t size) {
    int count = 0;
    char *token = strtok(buffer, " ");
    while (token != NULL && count < size - 1) {
        list[count++] = token;
        token = strtok(NULL, " ");
    }
    list[count] = NULL;
}

void print_char_array(char **array) {
    if (array == NULL) {
        printf("Array is NULL\n");
        return;
    }

    for (int i = 0; array[i] != NULL; i++) {
        printf("%s\n", array[i]);
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <PID>\n", argv[0]);
        return 1;
    }

    pid_t target_pid = atoi(argv[1]);
    char proc_path[PATH_SIZE];

    // Read the command line
    snprintf(proc_path, sizeof(proc_path), "/proc/%d/cmdline", target_pid);
    char cmdline[BUFFER_SIZE];
    read_file(proc_path, cmdline, sizeof(cmdline));

    // Parse the command line into argv format
    char *argv_list[BUFFER_SIZE];
    parse_buffer(cmdline, argv_list, BUFFER_SIZE);

    // Read the environment variables
    snprintf(proc_path, sizeof(proc_path), "/proc/%d/environ", target_pid);
    char envp[BUFFER_SIZE];
    read_file(proc_path, envp, sizeof(envp));

    // Parse the environment variables into envp_list format
    char *envp_list[BUFFER_SIZE];
    parse_buffer(envp, envp_list, BUFFER_SIZE);

    printf("variabili d'ambiente :\n");
    print_char_array(envp_list);

    // Read the current working directory
    snprintf(proc_path, sizeof(proc_path), "/proc/%d/cwd", target_pid);
    char cwd[PATH_SIZE];
    if (readlink(proc_path, cwd, sizeof(cwd) - 1) == -1) {
        perror("readlink");
        return 1;
    }

    // Read the executable path
    snprintf(proc_path, sizeof(proc_path), "/proc/%d/exe", target_pid);
    char exe_path[BUFFER_SIZE];
    if (readlink(proc_path, exe_path, sizeof(exe_path) - 1) == -1) {
        perror("readlink");
        return 1;
    }

    // Fork and exec the new process
    pid_t pid = fork();
    if (pid == -1) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {
        // Change to the target working directory
        if (chdir(cwd) == -1) {
            perror("chdir");
            exit(1);
        }

        // Execute the new process
        execve(exe_path, argv_list, envp_list);
        perror("execve");
        exit(1);
    } else {
        // Parent process
        printf("Started new process with PID %d\n", pid);
    }

    return 0;
}

```

# Esercizio 3

```python
import os
import stat

def find_symlinks(root):
    inode_to_paths = {}
    
    for dirpath, dirnames, filenames in os.walk(root):
        for name in dirnames + filenames:
            path = os.path.join(dirpath, name)
            if os.path.islink(path):
                try:
                    target = os.readlink(path)
                    # Resolve the absolute path of the symlink target
                    target_abs_path = os.path.abspath(os.path.join(dirpath, target))
                    # Get inode of the target file
                    inode = os.stat(target_abs_path, follow_symlinks=True).st_ino
                    if inode in inode_to_paths:
                        inode_to_paths[inode].append(path)
                    else:
                        inode_to_paths[inode] = [path]
                except FileNotFoundError:
                    # Handle broken symlinks
                    continue

    for inode, paths in inode_to_paths.items():
        if len(paths) > 1:
            print(f"Links pointing to the same inode ({inode}):")
            for path in paths:
                print(f"  {path}")

if __name__ == "__main__":
    root_directory = input("Enter the root directory to search: ")
    find_symlinks(root_directory)

```
