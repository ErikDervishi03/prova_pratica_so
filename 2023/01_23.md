> link alla prova : [http://www.cs.unibo.it/~renzo/so/pratiche/2024.01.19.pdf](http://www.cs.unibo.it/~renzo/so/pratiche/2023.01.23.pdf)

# Esercizio 1

```c
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

/*
  rimuove la pipe se gia' esiste
*/
void clear_pipe(const char * pipe_path){
  if (access(pipe_path, F_OK) == 0){
      remove(pipe_path); // mi libero del file se e' gia stato creato in precedenza
  }
}

int main(int argc, char * argv[]) {
  char *pipe_path;
  char * buff;
  FILE * fd;
  size_t len;
  size_t buflen = 0;

  strcpy(pipe_path, argv[1]);
  clear_pipe(pipe_path);

  if ( mkfifo(pipe_path, 0666) < 0 ){ // creo il named pipe
		perror( "Cannot create a pipe\n" );
	}

  while(1){

    fd = fopen(pipe_path, "r");
  
    while ( (len = getline(&buff, &buflen, fd ) > 0) ) {
	    	printf( "Received: %s", buff );

	    	if( strcmp(buff, "FINE\n") == 0 ) {	//compare buf con "FINE"
          printf("fine!\n");
          unlink(pipe_path);
				return 0;
			}
		}

    fclose(fd);
  }



  return 0;
}
```


# Esercizio 2

## fifosig
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include "s2argv.c"

/*
  rimuove la pipe se gia' esiste
*/
void clear_pipe(const char *pipe_path) {
    if (access(pipe_path, F_OK) == 0) {
        remove(pipe_path); // mi libero del file se e' gia stato creato in precedenza
    }
}

void ignore_new_line(char *str) {
    size_t len = strlen(str);
    if (len > 0 && str[len - 1] == '\n') {
        str[len - 1] = '\0';
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <pipe_path>\n", argv[0]);
        return 1;
    }

    char pipe_path[256];
    strncpy(pipe_path, argv[1], sizeof(pipe_path) - 1);
    pipe_path[sizeof(pipe_path) - 1] = '\0';
    clear_pipe(pipe_path);

    if (mkfifo(pipe_path, 0666) < 0) { // creo il named pipe
        perror("Cannot create a pipe");
        return 1;
    }

    char *buff = NULL;
    size_t buflen = 0;
    size_t len;
    FILE *fd;

    while (1) {
        fd = fopen(pipe_path, "r");
        if (!fd) {
            perror("fopen");
            return 1;
        }

        while ((len = getline(&buff, &buflen, fd)) != -1) {
            ignore_new_line(buff);
            char **arg = s2argv(buff);
            if (!arg) {
                fprintf(stderr, "s2argv failed\n");
                continue;
            }

            if (strcmp(buff, "FINE") == 0) { // compare buf con "FINE"
                printf("fine!\n");
                unlink(pipe_path);
                free(buff);
                s2argv_free(arg);
                fclose(fd);
                return 0;
            } else if (arg[0] && arg[1]){
                 
                printf("Sending signal [%s] to pid [%s]\n", arg[1], arg[0]);
                kill(atoi(arg[0]), atoi(arg[1]));

            }else {
              fprintf(stderr, "Invalid arguments\n");
            }
            s2argv_free(arg);
        }

        fclose(fd);
    }

    free(buff);
    return 0;
}


```

## test_fifosig

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>

void sighandler(int);

int main () {
   signal(SIGINT, sighandler);
   printf("my pid : %d\n", getpid());

   while(1) {
      printf("Going to sleep for 1 second...\n");
      sleep(1); 
   }
   return(0);
}

void sighandler(int signum) {
   printf("Caught signal %d, coming out...\n", signum);
   exit(1);
}
```

# Esercizio 3

```python
#!/usr/bin/env python3
import os
import sys
import shutil

def list_files(dir_path):
    f = []
    for (dirpath, dirnames, filenames) in os.walk(dir_path):
        f.extend(filenames)
        break
    return set(f)

def main():
    if len(sys.argv) != 3:
        print("Usage: python3 script.py <dir1_path> <dir2_path>")
        sys.exit(1)

    dir1_path = sys.argv[1]
    dir2_path = sys.argv[2]

    dir1 = list_files(dir1_path)
    dir2 = list_files(dir2_path)

    dir12 = dir1 & dir2

    new_dir1 = "new_" + os.path.basename(dir1_path)
    new_dir2 = "new_" + os.path.basename(dir2_path)

    os.makedirs(new_dir1, exist_ok=True)
    os.makedirs(new_dir2, exist_ok=True)

    for file in dir12:
        shutil.copyfile(os.path.join(dir1_path, file), os.path.join(new_dir1, file))
        shutil.copyfile(os.path.join(dir2_path, file), os.path.join(new_dir2, file))

if __name__ == "__main__":
    main()

```
