> link alla prova : http://www.cs.unibo.it/~renzo/so/pratiche/2023.01.19.pdf


# Esercizio 1

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_CMD_LEN 1024
#define MAX_ARGS 100

void ignore_new_line(char *str) {
    size_t len = strlen(str);
    if (len > 0 && str[len - 1] == '\n') {
        str[len - 1] = '\0';
    }
}

void parse_command(char *cmd, char **argv) {
    char *token = strtok(cmd, " ");
    int i = 0;
    while (token != NULL && i < MAX_ARGS - 1) {
        argv[i++] = token;
        token = strtok(NULL, " ");
    }
    argv[i] = NULL;
}

int main() {
    char cmd1[MAX_CMD_LEN];
    char cmd2[MAX_CMD_LEN];
    
    if (fgets(cmd1, sizeof(cmd1), stdin) == NULL) {
        perror("fgets");
        exit(EXIT_FAILURE);
    }
    if (fgets(cmd2, sizeof(cmd2), stdin) == NULL) {
        perror("fgets");
        exit(EXIT_FAILURE);
    }

    ignore_new_line(cmd1);
    ignore_new_line(cmd2);

    char *argv1[MAX_ARGS];
    char *argv2[MAX_ARGS];

    parse_command(cmd1, argv1);
    parse_command(cmd2, argv2);

    FILE *fp;
    char path[1035];

    int pipefd[2];
    pipe(pipefd); //tutto cio’ che scriviamo nel descrittore 1, lo possiamo poi leggere nel descrittore 0
    switch(fork()){
        case 0:{ //figlio
            dup2(pipefd[0],STDIN_FILENO);//Redirige stdin alla lettura dalla pipe
            close(pipefd[0]);
            close(pipefd[1]);
            execvp(argv2[0], argv2);
        } break;
    default:{ //padre
            dup2(pipefd[1],STDOUT_FILENO); // Redirige stdout alla scrittura nella pipe 
                                                   //qualsiasi cosa scritta in stdout verra' scritta in pipefd[1]
            close(pipefd[0]);
            close(pipefd[1]);
            execvp(argv1[0], argv1);
        }break;

    case -1: return 1; //errore
    }

    /*
        Anche se il figlio viene eseguito prima del padre:

        -Il figlio tenterà di leggere dall'estremità della pipe (pipefd[0]), ma non ci sarà nulla da leggere fino a quando 
        il padre non scriverà qualcosa nella pipe.
        -Il padre, quando esegue il comando, scriverà l'output nella pipe, che verrà poi letto dal figlio.

        Questo schema garantisce che il flusso di dati sia corretto indipendentemente dall'ordine di esecuzione dei processi
    */


    return 0;
}

```

# Esercizio 2

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_CMD_LEN 1024
#define MAX_CMDS 100
#define MAX_ARGS 100

void ignore_new_line(char *str) {
    size_t len = strlen(str);
    if (len > 0 && str[len - 1] == '\n') {
        str[len - 1] = '\0';
    }
}

void parse_command(char *cmd, char **argv) {
    char *token = strtok(cmd, " ");
    int i = 0;
    while (token != NULL && i < MAX_ARGS - 1) {
        argv[i++] = token;
        token = strtok(NULL, " ");
    }
    argv[i] = NULL;
}

void execute_command(char **argv, int input_fd, int output_fd) {
    if (input_fd != 0) { // Redirect input
        dup2(input_fd, STDIN_FILENO);
        close(input_fd);
    }
    if (output_fd != 1) { // Redirect output
        dup2(output_fd, STDOUT_FILENO);
        close(output_fd);
    }
    execvp(argv[0], argv); // Execute the command
    perror("execvp failed");
    exit(EXIT_FAILURE);
}

int main() {
    char cmds[MAX_CMDS][MAX_CMD_LEN];
    char *argvs[MAX_CMDS][MAX_ARGS];
    int cmd_count = 0;

    // Read commands from stdin
    while (fgets(cmds[cmd_count], sizeof(cmds[cmd_count]), stdin) != NULL) {
        ignore_new_line(cmds[cmd_count]);
        parse_command(cmds[cmd_count], argvs[cmd_count]);
        cmd_count++;
    }

    int pipes[MAX_CMDS - 1][2];
    for (int i = 0; i < cmd_count - 1; i++) {
        if (pipe(pipes[i]) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }
    }

    for (int i = 0; i < cmd_count; i++) {
        pid_t pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        } else if (pid == 0) {
            if (i != 0) {
                // Redirect stdin to the read end of the previous pipe
                int output_fd = (i == cmd_count - 1) ? STDOUT_FILENO : pipes[i][1];

                execute_command(argvs[i], pipes[i - 1][0], output_fd);
            } else {
                // First command
                execute_command(argvs[i], STDIN_FILENO, pipes[i][1]);
            }
        }
        // Parent process closes unused pipe ends
        if (i != 0) {
            close(pipes[i - 1][0]);
        }
        if (i != cmd_count - 1) {
            close(pipes[i][1]);
        }
    }

    // Wait for all child processes to finish
    for (int i = 0; i < cmd_count; i++) {
        wait(NULL);
    }

    return 0;
}
```

# Esercizio3

```python
#!/usr/bin/env python3

#soluzione scritta dal prof

import os
import sys

def copyapp(s, d):
  with open(s, 'r') as sf:
    with open(d, 'a') as df:
      df.write(sf.read())

def copyappdir(sd, dd):
  for d,_,fx in os.walk(sd):
    dstdir = dd + '/' + d[len(sd):]
    os.makedirs(dstdir, exist_ok=True)
    for f in fx:
      copyapp(sd + '/' + f, dstdir + '/' + f)

if name == "main":
  copyappdir(sys.argv[1], sys.argv[3])
  copyappdir(sys.argv[2], sys.argv[3])
```
