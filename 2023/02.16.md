> link alla prova : http://www.cs.unibo.it/~renzo/so/pratiche/2023.02.16.pdf

# Esercizio 1
> l'esercizio e' simile all'esempio che c'e' alla fine di questo manuale : https://www.man7.org/linux/man-pages/man2/mmap.2.html.
> rimane ugualmente molto tosto
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

#define handle_error(msg) \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

void copy_half(const char *src, const char *dest, off_t start, size_t size) {
    int src_fd = open(src, O_RDONLY);
    if (src_fd == -1) handle_error("open src");

    int dest_fd = open(dest, O_RDWR);
    if (dest_fd == -1) handle_error("open dest");

    size_t pagesize = sysconf(_SC_PAGESIZE);
    off_t pa_start = start & ~(pagesize - 1);
    off_t offset = start - pa_start;
    size_t map_size = size + offset;

    char *src_map = mmap(NULL, map_size, PROT_READ, MAP_PRIVATE, src_fd, pa_start);
    if (src_map == MAP_FAILED) handle_error("mmap src");

    char *dest_map = mmap(NULL, map_size, PROT_WRITE, MAP_SHARED, dest_fd, pa_start);
    if (dest_map == MAP_FAILED) handle_error("mmap dest");

    memcpy(dest_map + offset, src_map + offset, size);

    if (munmap(src_map, map_size) == -1) handle_error("munmap src");
    if (munmap(dest_map, map_size) == -1) handle_error("munmap dest");

    close(src_fd);
    close(dest_fd);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <source file> <destination file>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    const char *src = argv[1];
    const char *dest = argv[2];

    int src_fd = open(src, O_RDONLY);
    if (src_fd == -1) handle_error("open src");

    struct stat sb;
    if (fstat(src_fd, &sb) == -1) handle_error("fstat");

    size_t filesize = sb.st_size;

    int dest_fd = open(dest, O_RDWR | O_CREAT | O_TRUNC, 0666);
    if (dest_fd == -1) handle_error("open dest");

    if (ftruncate(dest_fd, filesize) == -1) handle_error("ftruncate");

    close(dest_fd);

    pid_t pid1, pid2;
    off_t half = filesize / 2;

    if ((pid1 = fork()) == 0) {
        copy_half(src, dest, 0, half);
        exit(EXIT_SUCCESS);
    }

    if ((pid2 = fork()) == 0) {
        copy_half(src, dest, half, filesize - half);
        exit(EXIT_SUCCESS);
    }

    int status;
    waitpid(pid1, &status, 0);
    waitpid(pid2, &status, 0);

    close(src_fd);

    return EXIT_SUCCESS;
}

```

# Esercizio 2

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <getopt.h>

#define handle_error(msg) \
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

void copy_range(const char *src, const char *dest, off_t start, off_t end) {
    int src_fd = open(src, O_RDONLY);
    if (src_fd == -1) handle_error("open src");

    int dest_fd = open(dest, O_RDWR);
    if (dest_fd == -1) handle_error("open dest");

    size_t pagesize = sysconf(_SC_PAGESIZE);
    off_t pa_start = start & ~(pagesize - 1);
    off_t offset = start - pa_start;
    size_t map_size = end - start + offset;

    char *src_map = mmap(NULL, map_size, PROT_READ, MAP_PRIVATE, src_fd, pa_start);
    if (src_map == MAP_FAILED) handle_error("mmap src");

    char *dest_map = mmap(NULL, map_size, PROT_WRITE, MAP_SHARED, dest_fd, pa_start);
    if (dest_map == MAP_FAILED) handle_error("mmap dest");

    memcpy(dest_map + offset, src_map + offset, end - start);

    if (munmap(src_map, map_size) == -1) handle_error("munmap src");
    if (munmap(dest_map, map_size) == -1) handle_error("munmap dest");

    close(src_fd);
    close(dest_fd);
}

int main(int argc, char *argv[]) {
    int num_processes = 1;  // default number of processes
    int opt;
    while ((opt = getopt(argc, argv, "j:")) != -1) {
        switch (opt) {
            case 'j':
                num_processes = atoi(optarg);
                break;
            default:
                fprintf(stderr, "Usage: %s -j <num_processes> <source file> <destination file>\n", argv[0]);
                exit(EXIT_FAILURE);
        }
    }

    if (argc - optind != 2) {
        fprintf(stderr, "Usage: %s -j <num_processes> <source file> <destination file>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    const char *src = argv[optind];
    const char *dest = argv[optind + 1];

    int src_fd = open(src, O_RDONLY);
    if (src_fd == -1) handle_error("open src");

    struct stat sb;
    if (fstat(src_fd, &sb) == -1) handle_error("fstat");

    off_t filesize = sb.st_size;
    off_t chunk_size = filesize / num_processes;
    off_t remainder = filesize % num_processes;
    off_t start = 0;

    int dest_fd = open(dest, O_RDWR | O_CREAT | O_TRUNC, 0666);
    if (dest_fd == -1) handle_error("open dest");

    if (ftruncate(dest_fd, filesize) == -1) handle_error("ftruncate");

    close(dest_fd);

    pid_t pid;
    for (int i = 0; i < num_processes; i++) {
        off_t end = start + chunk_size + (i < remainder ? 1 : 0);
        if ((pid = fork()) == 0) {
            copy_range(src, dest, start, end);
            exit(EXIT_SUCCESS);
        }
        start = end;
    }

    int status;
    for (int i = 0; i < num_processes; i++) {
        wait(&status);
    }

    close(src_fd);

    return EXIT_SUCCESS;
}

}

```

# Esercizio 3

```python
import os, sys

def dir_lines(root):
    record = []
    
    for dirpath, dirnames, filenames in os.walk(root):
        for name in dirnames + filenames:
            path = os.path.join(dirpath, name)
            
            if os.path.isfile(path):  # Assicuriamoci che sia un file
                with open(path, 'r', encoding='utf-8', errors='ignore') as file:
                    Lines = file.readlines()

                    for count, line in enumerate(Lines, start=1):
                        if len(record) < count:
                            record.append(0)
                        record[count - 1] += len(line) - 1 # -1 in quanto c'e' \n alla fine

    return record

if __name__ == "__main__":
    record = dir_lines(sys.argv[1])
    
    for count, value in enumerate(record, start=1):
        print(f"Line {count}: {value}")


```
