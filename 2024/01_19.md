> link alla prova : http://www.cs.unibo.it/~renzo/so/pratiche/2024.01.19.pdf

# Esercizio 1

## argsend

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void strcat_c(char *str, char c) {
    while (*str) str++;  // Scorri fino alla fine della stringa
    *str++ = c;          // Aggiungi il carattere
    *str = '\0';         // Aggiungi il terminatore della stringa
}

void print_(const char *str, size_t length) {
    for (size_t i = 0; i < length; i++) {
        if (str[i] == '\0') {
            printf("\\0");
        } else {
            printf("%c", str[i]);
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s [args]\n", argv[0]);
        return 1;
    }

    // Calcola la lunghezza totale necessaria per la stringa finale
    size_t total_length = 0;
    for (int i = 1; i < argc; i++) {
        total_length += strlen(argv[i]) + 1; // +1 per il terminatore della stringa '\0'
    }

    // Alloca memoria per la stringa finale
    char *final_string = (char *)malloc(total_length);
    if (!final_string) {
        perror("malloc failed");
        return 1;
    }

    // Inizializza la stringa finale
    final_string[0] = '\0';

    // Concatena tutti gli argomenti
    char *ptr = final_string;
    for (int i = 1; i < argc; i++) {
        strcpy(ptr, argv[i]);
        ptr += strlen(argv[i]);
        *ptr = '\0';
        ptr++;
    }

    // Stampa la stringa finale
    print_(final_string, total_length);

    // Libera la memoria allocata
    free(final_string);

    return 0;
}

```

## argrecv

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void strcat_c(char *str, char c) {
    while (*str) str++;  
    *str++ = c;          
    *str = '\0';         
}

char * format_buffer_into_command(char * buffer){

    char *argv = (char *)malloc(4096);

    int c = 0;

    for (int i = 0; i < strlen(buffer); i++) {
        if (buffer[i] != '\\') {
            strcat_c(argv, buffer[i]);
        } else {
            if (i + 1 >= strlen(buffer)) continue;
            else if (buffer[i + 1] == '0') {
                strcat_c(argv, ' ');
                i++;  
            }
        }
    }

    return argv;

}

int main() {
    char *buffer = NULL;
    size_t buffer_size = 0;
    ssize_t read_size;

    read_size = getline(&buffer, &buffer_size, stdin);

    char * command = format_buffer_into_command(buffer);

    printf("the command is : %s\n", command);
    system(command);

    free(command);
    free(buffer);

    return 1;
}

```

# Esercizio 2

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

void strcat_c(char *str, char c) {
    while (*str) str++;
    *str++ = c;
    *str = '\0';
}

char *format_buffer_into_command(char *buffer) {
    char *argv = (char *)malloc(4096);
    argv[0] = '\0';  // Initialize to an empty string

    for (int i = 0; i < strlen(buffer); i++) {
        if (buffer[i] != '\\') {
            strcat_c(argv, buffer[i]);
        } else {
            if (i + 1 >= strlen(buffer)) continue;
            else if (buffer[i + 1] == '0') {
                strcat_c(argv, ' ');
                i++;
            }
        }
    }

    return argv;
}


int main() {
    const char *pipe_path = "/tmp/mypipe";
    int fd;
    char buff[100];

    if (access(pipe_path, F_OK) == 0){
        remove(pipe_path); // mi libero del file se e' gia stato creato in precedenza
    }

    if ( mkfifo(pipe_path, 0666) < 0 ){ // creo il named pipe
		perror( "Cannot create a pipe\n" );
	}

    if ((fd = open(pipe_path, O_RDONLY)) == -1) { // provo ad aprire il file
        perror("open");
        exit(EXIT_FAILURE);
    }

    ssize_t bytes_read = read(fd, buff, sizeof(buff) - 1); // metto il contenuto di /tmp/mypipe in buff
 
    char *command = format_buffer_into_command(buff); 

    printf("The command is: %s\n", command);

    system(command);

    free(command);

    close(fd);
    return 0;
}

```

# Esercizio 3

```python
#!/usr/bin/env python3
import os
import sys

def list_files(dir_path):
    files = []
    for root, dirs, filenames in os.walk(dir_path):
        for name in dirs + filenames:
            files.append(os.path.relpath(os.path.join(root, name), dir_path))
    return set(files)

def compare_directories(dir1, dir2, option=None):
    files1 = list_files(dir1)
    files2 = list_files(dir2)

    if option == '-1':
        result = files1 - files2
    elif option == '-2':
        result = files2 - files1
    else:
        result = files1 & files2

    for path in sorted(result):
        print(path)

def main():

    if sys.argv[1] in ['-1', '-2']:
        option = sys.argv[1]
        dir1 = sys.argv[2]
        dir2 = sys.argv[3]
    else:
        option = None
        dir1 = sys.argv[1]
        dir2 = sys.argv[2]

    if not os.path.isdir(dir1) or not os.path.isdir(dir2):
        print("Both arguments must be directories")
        sys.exit(1)

    compare_directories(dir1, dir2, option)

if __name__ == "__main__":
    main()

```
