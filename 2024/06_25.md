> link alla prova : non c'e' ancora


# Esercizio 1

```c
#include <stdio.h>
#include <string.h>
#include <sys/inotify.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

#define EVENT_SIZE (sizeof(struct inotify_event))
#define EVENT_BUF_LEN (1024 * (EVENT_SIZE + 16))

void ignore_new_line(char *str) {
    size_t len = strlen(str);
    if (len > 0 && str[len - 1] == '\n') {
        str[len - 1] = '\0';
    }
}

int get_command(const char *file_name,char * argv[]){
    FILE *fp = fopen(file_name, "r");

    if (fp == NULL) {
        perror("file non aperto con successo. ABORT");
        exit(EXIT_FAILURE);
    }

    char buf[1024];

    int i = 0;

    while (fgets(buf, sizeof(buf), fp) != NULL) {
        ignore_new_line(buf);
        argv[i] = strdup(buf); // Allocate memory and copy the string
        i++;
    }
    argv[i] = NULL; // Null-terminate the array

    fclose(fp);

    return i;
}

void execute_file(const char *file_name) {
    printf("provo ad eseguire [%s]\n",file_name);
    pid_t pid = fork();

    if (pid == 0) {
        // Child process  
        char * argv[1024];

        int argc = get_command(file_name, argv);

        // Delete the file before execution
        if (remove(file_name) != 0) {
            perror("Failed to delete file");
        }

        if (execvp(argv[0], &argv[1]) == -1) {
            perror("execvp failed");
        }

        printf("\n");

        // Free allocated memory
        for (int j = 0; j < argc; j++) {
            free(argv[j]);
        }

        exit(EXIT_FAILURE);
    } else if (pid < 0) {
        // Fork failed
        perror("fork failed");
    }
    // Parent process continues without waiting for the child process
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <directory_to_watch>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int length, i = 0;
    int fd;
    int wd;
    char buffer[EVENT_BUF_LEN];

    /* creating the INOTIFY instance */
    fd = inotify_init();

    /* checking for error */
    if (fd < 0) {
        perror("inotify_init");
        exit(EXIT_FAILURE);
    }

    /* adding the directory into watch list with the correct event mask */
    wd = inotify_add_watch(fd, argv[1], IN_MOVED_TO | IN_CLOSE_WRITE);

    /* checking for error */
    if (wd < 0) {
        perror("inotify_add_watch");
        exit(EXIT_FAILURE);
    }

    /* read to determine the event change happens on the directory */
    while (1) {
        length = read(fd, buffer, EVENT_BUF_LEN);

        /* checking for error */
        if (length < 0) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        /* actually read returns the list of change events happens */
        while (i < length) {
            struct inotify_event *event = (struct inotify_event *) &buffer[i];
            if (event->len) {
                if (event->mask & (IN_MOVED_TO | IN_CLOSE_WRITE)) {
                    printf("New file %s moved to %s.\n", event->name, argv[1]);

                    // Build full path to the file
                    char full_path[1024];
                    snprintf(full_path, sizeof(full_path), "%s/%s", argv[1], event->name);
                    execute_file(full_path);
                
                }
            }
            i += EVENT_SIZE + event->len;
        }

        i = 0;
    }

    /* removing the directory from the watch list */
    inotify_rm_watch(fd, wd);

    /* closing the INOTIFY instance */
    close(fd);

    return 0;
}

```

# Esercizio 2

```c
#include <stdio.h>
#include <string.h>
#include <sys/inotify.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

#define EVENT_SIZE (sizeof(struct inotify_event))
#define EVENT_BUF_LEN (1024 * (EVENT_SIZE + 16))

void ignore_new_line(char *str) {
    size_t len = strlen(str);
    if (len > 0 && str[len - 1] == '\n') {
        str[len - 1] = '\0';
    }
}

/*
  prende il contenuto di file_name
  per esempio:
  
  /bin/cat
  cat
  /etc/hostname

  /bin/ls
  ls
  /tmp
  .
  e restiuisce un array di array di array di stringhe(piu' facile vedere che a dirsi ahahaha) 

  {{"/bin/cat,cat","/etc/hostname",NULL},{"/bin/ls","ls","/tmp",NULL},{NULL}}
*/
int get_command(const char *file_name, char ****argv) {
    FILE *fp = fopen(file_name, "r");

    if (fp == NULL) {
        perror("file non aperto con successo. ABORT");
        exit(EXIT_FAILURE);
    }

    char buf[1024];
    int cmd = 0;
    int i = 0;

    // Allocate initial memory for argv
    *argv = malloc(sizeof(char **) * 1024);
    (*argv)[cmd] = malloc(sizeof(char *) * 1024);

    while (fgets(buf, sizeof(buf), fp) != NULL) {
        ignore_new_line(buf);
        if (strcmp(buf, "") == 0) {
            (*argv)[cmd][i] = NULL; // Null-terminate the array
            cmd++;
            i = 0;
            (*argv)[cmd] = malloc(sizeof(char *) * 1024); // Allocate new command array
        } else {
            (*argv)[cmd][i] = strdup(buf); // Allocate memory and copy the string
            i++;
        }
    }
    
    (*argv)[cmd][i] = NULL;

    fclose(fp);

    return cmd + 1; // Return number of commands
}

void free_command(char ***argv, int argc) {
    for (int i = 0; i < argc; i++) {
        for (int j = 0; argv[i][j] != NULL; j++) {
            free(argv[i][j]);
        }
        free(argv[i]);
    }
    free(argv);
}

void execute_file(const char *file_name) {
    printf("provo ad eseguire [%s]\n", file_name);
    char ***argv;
    int argc = get_command(file_name, &argv);

    // Delete the file before execution
    if (remove(file_name) != 0) {
        perror("Failed to delete file");
    }

    for (int i = 0; i < argc; i++) {
      /*
        Il problema principale è che execvp sostituisce l'intero processo con il nuovo programma, 
        quindi per eseguire più comandi è necessario creare un nuovo processo figlio per ogni comando utilizzando fork
      */
        pid_t pid = fork();

        if (pid == 0) {
            // Child process
            if (execvp(argv[i][0], &argv[i][1]) == -1) {
                perror("execvp failed");
                exit(EXIT_FAILURE);
            }
        } else if (pid < 0) {
            // Fork failed
            perror("fork failed");
        }
    }

    free_command(argv, argc);
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        fprintf(stderr, "Usage: %s <directory_to_watch>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int length, i = 0;
    int fd;
    int wd;
    char buffer[EVENT_BUF_LEN];

    /* creating the INOTIFY instance */
    fd = inotify_init();

    /* checking for error */
    if (fd < 0) {
        perror("inotify_init");
        exit(EXIT_FAILURE);
    }

    /* adding the directory into watch list with the correct event mask */
    wd = inotify_add_watch(fd, argv[1], IN_MOVED_TO | IN_CLOSE_WRITE);

    /* checking for error */
    if (wd < 0) {
        perror("inotify_add_watch");
        exit(EXIT_FAILURE);
    }

    /* read to determine the event change happens on the directory */
    while (1) {
        length = read(fd, buffer, EVENT_BUF_LEN);

        /* checking for error */
        if (length < 0) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        /* actually read returns the list of change events happens */
        while (i < length) {
            struct inotify_event *event = (struct inotify_event *) &buffer[i];
            if (event->len) {
                if (event->mask & (IN_MOVED_TO | IN_CLOSE_WRITE)) {
                    printf("New file %s moved to %s.\n", event->name, argv[1]);

                    // Build full path to the file
                    char full_path[1024];
                    snprintf(full_path, sizeof(full_path), "%s/%s", argv[1], event->name);
                    execute_file(full_path);
                }
            }
            i += EVENT_SIZE + event->len;
        }

        i = 0;
    }

    /* removing the directory from the watch list */
    inotify_rm_watch(fd, wd);

    /* closing the INOTIFY instance */
    close(fd);

    return 0;
}

```

# Esercizio3
```bash
#!/bin/bash

# Verifica che sia stata passata una directory come parametro
if [ $# -ne 1 ]; then
    echo "Usage: $0 <directory>"
    exit 1
fi

# Funzione per ottenere la stringa di permessi di un file
get_permission_string() {
    local file="$1"
    stat -c "%A" "$file"
}

# Directory di input
input_directory="$1"

# Verifica che la directory esista
if [ ! -d "$input_directory" ]; then
    echo "Error: $input_directory does not exist or is not a directory."
    exit 1
fi

# Ciclo su tutti i file nella directory di input
for file in "$input_directory"/*; do
    [ -e "$file" ] || continue  # Salta se il file non esiste
    [ -f "$file" ] || continue  # Salta se non è un file regolare

    # Ottiene la stringa di permessi del file
    perm_string=$(get_permission_string "$file")

    # Crea la directory per i permessi se non esiste
    perm_dir="$input_directory/$perm_string"
    if [ ! -d "$perm_dir" ]; then
        mkdir -p "$perm_dir"
    fi

    # Crea un collegamento simbolico al file nella directory dei permessi
    symlink_path="$perm_dir/$(basename "$file")"
    if [ ! -e "$symlink_path" ]; then
        ln -s "$(realpath "$file")" "$symlink_path"
    fi
done
```
