> link della prova : http://www.cs.unibo.it/~renzo/so/pratiche/2024.02.14.pdf

# Esercizio 1

```c
#include <stdio.h>
#include <dirent.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <linux/limits.h>

int isELF (FILE* file){
  char ch;
  char control[4] = {0x7f, 'E', 'L', 'F'};

  for (int i = 0 ; i < 4; i++ ){
    if((ch = fgetc(file)) == EOF || control[i] != ch) return 0;
  }

  return 1;
}

int isSCRIPT(FILE* file){
  char ch;
  char control[2] = {'#','!'};

  for (int i = 0 ; i < 2; i++ ){
    if((ch = fgetc(file)) == EOF || control[i] != ch) return 0;
  }

  return 1;
}


int listdir(const char *path) 
{
    struct dirent *entry;
    DIR *dp;
    struct stat buffer;

    dp = opendir(path);
    if (dp == NULL) 
    {
        perror("opendir");
        return -1;
    }

    while((entry = readdir(dp))) 
    {
        // Skip "." and ".." entries
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        // Create the full path
        char full_path[PATH_MAX];
        snprintf(full_path, PATH_MAX, "%s/%s", path, entry->d_name);

        if (stat(full_path, &buffer) == -1) 
        {
            perror("stat");
            continue;
        }

        if (S_ISDIR(buffer.st_mode)) 
        {
            listdir(full_path); // Recursively list the directory
        } 
        else 
        {
            if(isELF(fopen(full_path, "r")))
              printf("%s : ELF eseguibile\n", full_path);
            else if (isSCRIPT(fopen(full_path, "r")))
              printf("%s : SCRIPT\n", full_path);
        }
    }

    closedir(dp);
    return 0;
}

int main(void) 
{ 
    listdir(".");
    return 0; 
}
```
# Esercizio 2

```c
#include <stdio.h>
#include <dirent.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <linux/limits.h>

int run_name(const char *path, const char * name, char * argv[]) 
{
    struct dirent *entry;
    DIR *dp;
    struct stat buffer;

    dp = opendir(path);
    if (dp == NULL) 
    {
        perror("opendir");
        return -1;
    }

    while((entry = readdir(dp))) 
    {
        // Skip "." and ".." entries
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        // Create the full path
        char full_path[PATH_MAX];
        snprintf(full_path, PATH_MAX, "%s/%s", path, entry->d_name);

        if (stat(full_path, &buffer) == -1) 
        {
            perror("stat");
            continue;
        }

        if (S_ISDIR(buffer.st_mode)) 
        {
            run_name(full_path, name , argv); // Recursively list the directory
        } 
        else if(buffer.st_mode & S_IXUSR && strcmp(entry->d_name, name) == 0)
        { 
            char *newenviron[] = { NULL };
            execve(full_path, argv, newenviron);
        }
    }

    closedir(dp);
    return 0;
}

int main(int argc, char * argv[]) 
{ 
    run_name(".", argv[1], &argv[1]);
    return 0; 
}

```

# Esercizio 3

```python
import os
import sys
import subprocess

def categorize_files(directory):
    categories = {}

    for root, dirs, files in os.walk(directory):
        for name in dirs + files:
            path = os.path.join(root, name)
            if os.path.isdir(path):
                file_type = 'directory'
            else:
                file_type = subprocess.getoutput(f'file -b "{path}"')
            if file_type not in categories:
                categories[file_type] = []
            categories[file_type].append(name)

    return categories

def print_catalog(categories):
    for category, items in categories.items():
        print(f"{category}:")
        for item in items:
            print(f"  {item}")
        print()

if __name__ == "__main__":
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        directory = os.getcwd()

    categories = categorize_files(directory)
    print_catalog(categories)

```

